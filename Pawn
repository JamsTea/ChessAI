import java.awt.*;
import java.util.ArrayList;
import java.util.List;

public class Pawn extends Piece  {
    public Pawn(int position, Color color, Board board) {
        super(position, color, board);
    }





    @Override
    public List<Integer> findLegalMoves(Board board) { //Initialise an empty list which will store all of it's legal moves
        List<Integer> legalMoves = new ArrayList<>();

        int [][] cBoard = new int [8][8];
        int tileNumber =1;
        for (int row = 0; row < 8; row++) {
            for (int col = 0; col < 8; col++) {
                cBoard[row][col] = tileNumber;
                tileNumber++;
            }
        }

        int currentPosition = getPosition(); //Get the current position for the pawn
        int currentXVal = currentPosition / 8; //Calculates the current X position
        int currentYVal = currentPosition % 8; //Calculates the current Y position

        int whiteDiagLeftXCord= currentXVal-1;
        int whiteDiagLeftYCord = currentYVal-1;
        int whiteDiagRightXCord = currentXVal+1;
        int whiteDiagRightYCord = currentYVal +1;

        int blackDiagLeftXCord = currentXVal-1;
        int blackDiagLeftYCord = currentYVal+1;
        int blackDiagRightXCord = currentXVal+1;
        int blackDiagRightYCord = currentYVal+1;

        int oneTileForward;

        if (getColor() == Color.WHITE) { //Check if the pawn is white
            oneTileForward = currentPosition - 8; //Moves the pawn up by 1 tile ahead

            if (!board.getPosition(oneTileForward, currentYVal).isOccupied()) {
                return legalMoves;
            }
            legalMoves.add(oneTileForward);

            //if statements to check whether the white pawn on its diagonal left is an enemy piece
            if (board.getPosition(whiteDiagLeftXCord,whiteDiagLeftYCord).getPiece()==blackPawn ||
                    board.getPosition(whiteDiagLeftXCord, whiteDiagLeftYCord).getPiece()==blackBishop ||
                    board.getPosition(whiteDiagLeftXCord,whiteDiagLeftYCord).getPiece()== blackKing ||
                    board.getPosition(whiteDiagLeftXCord, whiteDiagLeftYCord).getPiece()==blackKnight ||
                    board.getPosition(whiteDiagLeftXCord, whiteDiagLeftYCord).getPiece()== blackQueen ||
                    board.getPosition(whiteDiagLeftXCord,whiteDiagLeftYCord).getPiece()== blackRook) {


                return legalMoves;
        }
            legalMoves.add(cBoard[whiteDiagLeftXCord][whiteDiagLeftYCord]);

        //If statements to check whether the white pawn on its diagonal right is an enemy piece
            if (board.getPosition(whiteDiagRightXCord, whiteDiagRightYCord).getPiece() == blackPawn ||
                    board.getPosition(whiteDiagRightXCord, whiteDiagRightYCord).getPiece() == blackBishop ||
                    board.getPosition(whiteDiagRightXCord, whiteDiagRightYCord).getPiece() == blackKing ||
                    board.getPosition(whiteDiagRightXCord , whiteDiagRightYCord).getPiece () == blackKnight ||
                    board.getPosition(whiteDiagRightXCord, whiteDiagRightYCord).getPiece()== blackQueen ||
                    board.getPosition(whiteDiagRightXCord, whiteDiagRightYCord).getPiece()== blackRook) {
                return legalMoves;
            }
            legalMoves.add(cBoard[whiteDiagRightXCord][whiteDiagRightYCord]);
        }


        else { //For the black pawn
            oneTileForward = currentPosition + 8; //Moves the pawn up by 1 tile ahead
            if (!board.getPosition(oneTileForward,currentYVal).isOccupied()) {
                return legalMoves;
            }
            legalMoves.add(oneTileForward); //If the tile ahead is not occupied, add it as one of it's legal moves

            //if statements to check whether the black pawn on its diagonal left is an enemy piece
            if (board.getPosition(blackDiagLeftXCord, blackDiagLeftYCord).getPiece() == whitePawn ||
                    board.getPosition(blackDiagLeftXCord, blackDiagLeftYCord).getPiece() == whiteBishop ||
                    board.getPosition(blackDiagLeftXCord ,blackDiagLeftYCord).getPiece() == whiteKing ||
                    board.getPosition(blackDiagLeftXCord , blackDiagLeftYCord).getPiece () == whiteKnight ||
                    board.getPosition(blackDiagLeftXCord, blackDiagLeftYCord).getPiece()== whiteQueen ||
                    board.getPosition(blackDiagLeftXCord, blackDiagLeftYCord).getPiece()== whiteRook) {
                return legalMoves;}
         //   legalMoves.add(blackDiagLeftXCord, blackDiagLeftYCord);
            legalMoves.add(cBoard[blackDiagLeftXCord][blackDiagLeftYCord]);

            //if statement to check whether the black pawn on its diagonal right is an enemy piece
            if (board.getPosition(blackDiagRightXCord,blackDiagRightYCord).getPiece() == whitePawn ||
                    board.getPosition(blackDiagRightXCord, blackDiagRightYCord).getPiece() == whiteBishop ||
                    board.getPosition(blackDiagRightXCord, blackDiagRightYCord).getPiece() == whiteKing ||
                    board.getPosition(blackDiagRightXCord , blackDiagRightYCord).getPiece () == whiteKnight ||
                    board.getPosition(blackDiagRightXCord, blackDiagRightYCord).getPiece()== whiteQueen ||
                    board.getPosition(blackDiagRightXCord, blackDiagRightYCord).getPiece()== whiteRook) {
                return legalMoves;}
            //legalMoves.add(blackDiagRightXCord,blackDiagRightYCord);
            legalMoves.add(cBoard[blackDiagRightXCord][blackDiagRightYCord]);
        }

        return legalMoves;}

    public void move (int newPosition){
        setPosition(newPosition);
    }


}






